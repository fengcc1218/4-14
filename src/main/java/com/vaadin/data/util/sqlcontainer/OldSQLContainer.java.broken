/*
 * Copyright 2000-2013 Vaadin Ltd.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.vaadin.data.util.sqlcontainer;

import java.io.IOException;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.ConcurrentModificationException;
import java.util.Date;
import java.util.EventObject;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vaadin.data.Container;
import com.vaadin.data.ContainerHelpers;
import com.vaadin.data.Item;
import com.vaadin.data.Property;
import com.vaadin.data.util.filter.Compare.Equal;
import com.vaadin.data.util.filter.Like;
import com.vaadin.data.util.filter.UnsupportedFilterException;
import com.vaadin.data.util.sqlcontainer.query.OracleQuery;
import com.vaadin.data.util.sqlcontainer.query.OrderBy;
import com.vaadin.data.util.sqlcontainer.query.QueryDelegate;
import com.vaadin.data.util.sqlcontainer.query.QueryDelegate.RowIdChangeListener;
import com.vaadin.data.util.sqlcontainer.query.TableQuery;
import com.vaadin.data.util.sqlcontainer.query.generator.MSSQLGenerator;
import com.vaadin.data.util.sqlcontainer.query.generator.OracleGenerator;

import edu.missouri.cf.projex4.data.OracleObjectMapper;
import edu.missouri.cf.projex4.data.ProjexContainer;

@SuppressWarnings("serial")
public class OldSQLContainer implements ProjexContainer {

	// set to true to turn on extra OldSQLContainer debugging.
	boolean debug = false;
	private boolean isComboBox = false;
	
	private static final Logger logger = LoggerFactory.getLogger(OldSQLContainer.class);

	/** Query delegate */
	private QueryDelegate delegate;
	/** Auto commit mode, default = false */
	private boolean autoCommit = false;

	/** Page length = number of items contained in one page */
	private int pageLength = DEFAULT_PAGE_LENGTH;
	public static final int DEFAULT_PAGE_LENGTH = 50;

	/** Number of items to cache = CACHE_RATIO x pageLength */
	public static final int CACHE_RATIO = 3;
	
	/** Amount of cache to overlap with previous page */
    private int cacheOverlap = pageLength;

	/** Item and index caches */
	private final Map<Integer, RowId> itemIndexes = new HashMap<Integer, RowId>();
	private final CacheMap<RowId, RowItem> cachedItems = new CacheMap<RowId, RowItem>();

	/** Container properties = column names, data types and statuses */
	private final List<String> propertyIds = new ArrayList<String>();
	private final Map<String, Class<?>> propertyTypes = new HashMap<String, Class<?>>();
	private final Map<String, Class<?>> overrideTypes = new HashMap<String, Class<?>>();
	private final Map<String, Boolean> propertyReadOnly = new HashMap<String, Boolean>();
	private final Map<String, Boolean> propertyPersistable = new HashMap<String, Boolean>();
	private final Map<String, Boolean> propertyNullable = new HashMap<String, Boolean>();
	private final Map<String, Boolean> propertyPrimaryKey = new HashMap<String, Boolean>();

	/** Filters (WHERE) and sorters (ORDER BY) */
	private final List<Filter> filters = new ArrayList<Filter>();
	private final List<OrderBy> sorters = new ArrayList<OrderBy>();

	/**
	 * Total number of items available in the data source using the current
	 * query, filters and sorters.
	 */
	private int size;

	/**
	 * Size updating logic. Do not update size from data source if it has been
	 * updated in the last sizeValidMilliSeconds milliseconds.
	 */
	private final int sizeValidMilliSeconds = 10000;
	private boolean sizeDirty = true;
	private Date sizeUpdated = new Date();

	/** Starting row number of the currently fetched page */
	private int currentOffset;

	/** ItemSetChangeListeners */
	private LinkedList<Container.ItemSetChangeListener> itemSetChangeListeners;

	/** Temporary storage for modified items and items to be removed and added */
	private final Map<RowId, RowItem> removedItems = new HashMap<RowId, RowItem>();
	private final List<RowItem> addedItems = new ArrayList<RowItem>();
	private final List<RowItem> modifiedItems = new ArrayList<RowItem>();

	/** List of references to other OldSQLContainers */
	private final Map<OldSQLContainer, Reference> references = new HashMap<OldSQLContainer, Reference>();

	/** Cache flush notification system enabled. Disabled by default. */
	private boolean notificationsEnabled;
	
	/**
	 * Prevent instantiation without a QueryDelegate.
	 */
	@SuppressWarnings("unused")
	private OldSQLContainer() {
	}

	/**
	 * Creates and initializes OldSQLContainer using the given QueryDelegate
	 * 
	 * @param delegate
	 *            QueryDelegate implementation
	 * @throws SQLException
	 */
	public OldSQLContainer(QueryDelegate delegate) throws SQLException {
		if (delegate == null) {
			throw new IllegalArgumentException("QueryDelegate must not be null.");
		}
		this.delegate = delegate;
		objectMapper = new OracleObjectMapper();
		getPropertyIds(); // Queries Database.
		cachedItems.setCacheLimit(CACHE_RATIO * getPageLength() + cacheOverlap);
	}

	public void overrideType(Object propertyId, Class<?> propertyClass) {
		overrideTypes.put(propertyId.toString(), propertyClass);
	}

	/**************************************/
	/** Methods from interface Container **/
	/**************************************/

	/**
	 * Note! If auto commit mode is enabled, this method will still return the
	 * temporary row ID assigned for the item. Implement
	 * QueryDelegate.RowIdChangeListener to receive the actual Row ID value
	 * after the addition has been committed.
	 * 
	 * {@inheritDoc}
	 */

	@Override
	public Object addItem() throws UnsupportedOperationException {
		Object emptyKey[] = new Object[delegate.getPrimaryKeyColumns().size()];
		RowId itemId = new TemporaryRowId(emptyKey);
		// Create new empty column properties for the row item.
		List<ColumnProperty> itemProperties = new ArrayList<ColumnProperty>();
		for (String propertyId : propertyIds) {
			/* Default settings for new item properties. */
			ColumnProperty cp = new ColumnProperty(propertyId, propertyReadOnly.get(propertyId), propertyPersistable.get(propertyId),
					propertyNullable.get(propertyId), propertyPrimaryKey.get(propertyId), null, getType(propertyId));

			itemProperties.add(cp);
		}

		RowItem newRowItem = new RowItem(this, itemId, itemProperties);

		if (autoCommit) {
			/* Add and commit instantly */
			try {
				if (delegate instanceof TableQuery) {
					itemId = ((TableQuery) delegate).storeRowImmediately(newRowItem);
				} else {
					delegate.beginTransaction();
					delegate.storeRow(newRowItem);
					delegate.commit();
				}
				refresh();
				if (notificationsEnabled) {
					CacheFlushNotifier.notifyOfCacheFlush(this);
				}
				logger.debug("Row added to DB...");
				return itemId;
			} catch (SQLException e) {
				logger.warn("Failed to add row to DB. Rolling back.", e);
				try {
					delegate.rollback();
				} catch (SQLException ee) {
					logger.error("Failed to roll back row addition", e);
				}
				return null;
			}
		} else {
			addedItems.add(newRowItem);
			fireContentsChange();
			return itemId;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#containsId(java.lang.Object)
	 */

	@Override
	public boolean containsId(Object itemId) {
		if (debug) 
			logger.debug("\n\n");
		if (itemId == null) {
			logger.debug("itemId was null.");
			return false;
		}
		if (debug) 
			logger.debug("containsID itemId = {}, class = {}", itemId, itemId.getClass());

		if (cachedItems.containsKey(itemId)) {
			if (debug) 
				logger.debug("itemId was contained in cachedItems");
			return true;
		} else {
			if (debug) 
				logger.debug("itemId was not contained in cachedItems.");
			for (RowItem item : addedItems) {
				if (debug) 
					logger.debug("checking {} with itemId = {}", item.getId(), itemId);
				if (item.getId().equals(itemId)) {
					if (debug) {
						logger.debug("itemId was found in addedItems");
						logger.debug("itemPassesFilters({}) = {}", item, itemPassesFilters(item));
					}
					return itemPassesFilters(item);
				}
			}
			if (debug) 
				logger.debug("itemId was not found in addedItems");
		}
		if (removedItems.containsKey(itemId)) {
			if (debug) 
				logger.debug("itemId was found in removedItems");
			return false;
		}

		if (itemId instanceof ReadOnlyRowId) {
			int rowNum = ((ReadOnlyRowId) itemId).getRowNum();
			logger.debug("checking whether rowNum " + rowNum + " exists in cache for ReadOnlyRowId");
			return rowNum >= 0 && rowNum < size;
		}

		if (itemId instanceof RowId && !(itemId instanceof TemporaryRowId)) {
			try {
				boolean found = delegate.containsRowWithKey(((RowId) itemId).getId());
				if (debug) 
					logger.debug("itemId is an instanceof RowId and needs to be checked by delegate." + ((RowId) itemId).getId().toString() + " found = " + found);
				return found;
			} catch (Exception e) {
				/* Query failed, just return false. */
				logger.warn("containsId query failed", e);
			}
		}
		return false;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#getContainerProperty(java.lang.Object,
	 * java.lang.Object)
	 */

	@SuppressWarnings("rawtypes")
	@Override
	public Property getContainerProperty(Object itemId, Object propertyId) {
		Item item = getItem(itemId);
		if (item == null) {
			return null;
		}
		return item.getItemProperty(propertyId);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#getContainerPropertyIds()
	 */

	@Override
	public Collection<?> getContainerPropertyIds() {
		return Collections.unmodifiableCollection(propertyIds);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#getItem(java.lang.Object)
	 */

	@Override
	public Item getItem(Object itemId) {
		if (debug) {
			logger.debug("getItem({})", itemId);
			//logger.debug("class = {}", itemId != null ? itemId.getClass() : null);
		}
		if (!cachedItems.containsKey(itemId)) {
			int index = indexOfId(itemId);
			//logger.debug("index {} >= size {}", index, size);
			//logger.debug("index + removedItems = {}", index + removedItems.size());
			if ((index + removedItems.size()) >= size) {
				// The index is in the added items
				//int offset = index + removedItems.size() - size;
				int offset = index - size;
				RowItem item = addedItems.get(offset);
				if (itemPassesFilters(item)) {
					return item;
				} else {
					return null;
				}
			} else {
				// load the item into cache
				updateOffsetAndCache(index);
			}
		}
		return cachedItems.get(itemId);
	}

	/**
	 * Bypasses in-memory filtering to return items that are cached in memory.
	 * <em>NOTE</em>: This does not bypass database-level filtering.
	 * 
	 * @param itemId
	 *            the id of the item to retrieve.
	 * @return the item represented by itemId.
	 */
	public Item getItemUnfiltered(Object itemId) {
		if (!cachedItems.containsKey(itemId)) {
			for (RowItem item : addedItems) {
				if (item.getId().equals(itemId)) {
					return item;
				}
			}
		}
		return cachedItems.get(itemId);
	}

	/**
	 * NOTE! Do not use this method if in any way avoidable. This method doesn't
	 * (and cannot) use lazy loading, which means that all rows in the database
	 * will be loaded into memory.
	 * 
	 * {@inheritDoc}
	 */

	@Override
	public Collection<?> getItemIds() {
		updateCount();
		ArrayList<RowId> ids = new ArrayList<RowId>();
		ResultSet rs = null;
		try {
			// Load ALL rows :(
			delegate.beginTransaction();
			rs = delegate.getResults(0, 0);
			List<String> pKeys = delegate.getPrimaryKeyColumns();
			while (rs.next()) {
				RowId id = null;
				if (pKeys.isEmpty()) {
					/* Create a read only itemId */
					id = new ReadOnlyRowId(rs.getRow());
				} else {
					/* Generate itemId for the row based on primary key(s) */
					Object[] itemId = new Object[pKeys.size()];
					for (int i = 0; i < pKeys.size(); i++) {
						itemId[i] = rs.getObject(pKeys.get(i));
					}
					id = new RowId(itemId);
				}
				if (id != null && !removedItems.containsKey(id)) {
					ids.add(id);
				}
			}
			rs.getStatement().close();
			rs.close();
			delegate.commit();
		} catch (SQLException e) {
			logger.warn("getItemIds() failed, rolling back.", e);
			try {
				delegate.rollback();
			} catch (SQLException e1) {
				logger.error("Failed to roll back state", e1);
			}
			try {
				rs.getStatement().close();
				rs.close();
			} catch (SQLException e1) {
				logger.warn("Closing session failed", e1);
			}
			throw new RuntimeException("Failed to fetch item indexes.", e);
		}
		for (RowItem item : getFilteredAddedItems()) {
			ids.add(item.getId());
		}
		return Collections.unmodifiableCollection(ids);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#getType(java.lang.Object)
	 * 
	 * CCG Changed to allow type overriding.
	 */

	@Override
	public Class<?> getType(Object propertyId) {
		if (!propertyIds.contains(propertyId)) {
			return null;
		}
		if (overrideTypes.containsKey(propertyId)) {
			return overrideTypes.get(propertyId);
		}
		return propertyTypes.get(propertyId);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#size()
	 */

	@Override
	public int size() {
		if (debug) 
			logger.debug("size()");
		updateCount();
		//logger.debug("total size = {}, size = {}, added = {}, removed = {}", size + sizeOfAddedItems() - removedItems.size()
		//		, size, sizeOfAddedItems(), removedItems.size());
		return size + sizeOfAddedItems() - removedItems.size();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#removeItem(java.lang.Object)
	 */

	@Override
	public boolean removeItem(Object itemId) throws UnsupportedOperationException {
		if (!containsId(itemId)) {
			return false;
		}
		for (RowItem item : addedItems) {
			if (item.getId().equals(itemId)) {
				addedItems.remove(item);
				fireContentsChange();
				return true;
			}
		}

		if (autoCommit) {
			/* Remove and commit instantly. */
			Item i = getItem(itemId);
			if (i == null) {
				return false;
			}
			try {
				delegate.beginTransaction();
				boolean success = delegate.removeRow((RowItem) i);
				delegate.commit();
				refresh();
				if (notificationsEnabled) {
					CacheFlushNotifier.notifyOfCacheFlush(this);
				}
				if (success) {
					logger.debug("Row removed from DB...");
				}
				return success;
			} catch (SQLException e) {
				logger.warn("Failed to remove row, rolling back", e);
				try {
					delegate.rollback();
				} catch (SQLException ee) {
					/* Nothing can be done here */
					logger.error("Failed to rollback row removal", ee);
				}
				return false;
			} catch (OptimisticLockException e) {
				logger.warn("Failed to remove row, rolling back", e);
				try {
					delegate.rollback();
				} catch (SQLException ee) {
					/* Nothing can be done here */
					logger.error("Failed to rollback row removal", ee);
				}
				throw e;
			}
		} else {
			removedItems.put((RowId) itemId, (RowItem) getItem(itemId));
			cachedItems.remove(itemId);
			refresh();
			return true;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#removeAllItems()
	 */

	@Override
	public boolean removeAllItems() throws UnsupportedOperationException {
		if (autoCommit) {
			/* Remove and commit instantly. */
			try {
				delegate.beginTransaction();
				boolean success = true;
				for (Object id : getItemIds()) {
					if (!delegate.removeRow((RowItem) getItem(id))) {
						success = false;
					}
				}
				if (success) {
					delegate.commit();
					logger.debug("All rows removed from DB...");
					refresh();
					if (notificationsEnabled) {
						CacheFlushNotifier.notifyOfCacheFlush(this);
					}
				} else {
					delegate.rollback();
				}
				return success;
			} catch (SQLException e) {
				logger.warn("removeAllItems() failed, rolling back", e);
				try {
					delegate.rollback();
				} catch (SQLException ee) {
					/* Nothing can be done here */
					logger.error("Failed to roll back", ee);
				}
				return false;
			} catch (OptimisticLockException e) {
				logger.warn("removeAllItems() failed, rolling back", e);
				try {
					delegate.rollback();
				} catch (SQLException ee) {
					/* Nothing can be done here */
					logger.error("Failed to roll back", ee);
				}
				throw e;
			}
		} else {
			for (Object id : getItemIds()) {
				removedItems.put((RowId) id, (RowItem) getItem(id));
				cachedItems.remove(id);
			}
			refresh();
			return true;
		}
	}

	/*************************************************/
	/** Methods from interface Container.Filterable **/
	/*************************************************/

	
	private boolean autoRefresh = true;

	/**
	 * Defers refresh on filter manipulation when set to false.
	 * 
	 * @param refresh
	 */
	@Deprecated
	public void setFilterRefresh(boolean refresh) {
		setAutoRefresh(refresh);
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @see addContainerFilter(Filter filter, boolean refresh)
	 */

	@Override
	public void addContainerFilter(Filter filter) throws UnsupportedFilterException {
//		if (debug) {
			if (filter instanceof Equal) {
				logger.debug("addContainerFilter filter : {} = {}", new Object[] { ((Equal) filter).getPropertyId(), ((Equal) filter).getValue() });
			} else {
				logger.debug("addContainerFilter filter : " + filter.toString());
			}
//		}

		filters.add(filter);

		if (autoRefresh) {
			refresh();
		}
		
	}
	
	/**
	 * {@inheritDoc}
	 * 
	 * @see removeContainerFilter(Filter filter, boolean refresh)
	 */

	@Override
	public void removeContainerFilter(Filter filter) {
		logger.debug("removeContainerFilter({})", filter);
		filters.remove(filter);
		if (autoRefresh) {
			// added this if statement to bypass refreshing a combobox.
			//if (!isComboBox) {
				refresh();
			//} 
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public void addContainerFilter(Object propertyId, String filterString, boolean ignoreCase, boolean onlyMatchPrefix) {
		logger.debug("Old addContainerFilter called");
		if (propertyId == null || !propertyIds.contains(propertyId)) {
			return;
		}

		/* Generate Filter -object */
		String likeStr = onlyMatchPrefix ? filterString + "%" : "%" + filterString + "%";
		Like like = new Like(propertyId.toString(), likeStr);
		like.setCaseSensitive(!ignoreCase);
		filters.add(like);
		if (autoRefresh) {
			refresh();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public void removeContainerFilters(Object propertyId) {
		ArrayList<Filter> toRemove = new ArrayList<Filter>();
		for (Filter f : filters) {
			if (f.appliesToProperty(propertyId)) {
				toRemove.add(f);
			}
		}
		filters.removeAll(toRemove);
		if (autoRefresh) {
			refresh();
		}
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @see removeAllContainerFilters(boolean refresh)
	 */
	@Override
	public void removeAllContainerFilters() {
		filters.clear();
		if (autoRefresh) {
			refresh();
		}
	}

	/**
	 * Returns true if any filters have been applied to the container.
	 * 
	 * @return true if the container has filters applied, false otherwise
	 * @since 7.1
	 */
	public boolean hasContainerFilters() {
		return !getContainerFilters().isEmpty();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Filterable#getContainerFilters()
	 */
	@Override
	public Collection<Filter> getContainerFilters() {
		return Collections.unmodifiableCollection(filters);
	}

	/**********************************************/
	/** Methods from interface Container.Indexed **/
	/**********************************************/

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Indexed#indexOfId(java.lang.Object)
	 */

	@Override
	public int indexOfId(Object itemId) {
		if (debug) 
			logger.debug("indexOfId({})", itemId);
		// First check if the id is in the added items
		for (int ix = 0; ix < addedItems.size(); ix++) {
			RowItem item = addedItems.get(ix);
			if (item.getId().equals(itemId)) {
				if (itemPassesFilters(item)) {
					updateCount();
					return size + ix;
				} else {
					return -1;
				}
			}
		}

		if (!containsId(itemId)) {
			return -1;
		}
		if (cachedItems.isEmpty()) {
			getPage();
		}
		int size = size();
		// this protects against infinite looping
		int counter = 0;
		int oldIndex;
		while (counter < size) {
			if (itemIndexes.containsValue(itemId)) {
                for (Integer idx : itemIndexes.keySet()) {
                    if (itemIndexes.get(idx).equals(itemId)) {
                        return idx;
                    }
                }
            }
            oldIndex = currentOffset;
            // load in the next page.
            int nextIndex = currentOffset + pageLength * CACHE_RATIO
                    + cacheOverlap;
            if (nextIndex >= size) {
                // Container wrapped around, start from index 0.
                nextIndex = 0;
            }
            updateOffsetAndCache(nextIndex);

            // Update counter
            if (currentOffset > oldIndex) {
                counter += currentOffset - oldIndex;
            } else {
                counter += size - oldIndex;
            }
		}
		// safeguard in case item not found
		return -1;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Indexed#getIdByIndex(int)
	 */

	@Override
	public Object getIdByIndex(int index) {
		if (debug) 
			logger.debug("getIdByIndex({})", index);
		if (index < 0) {
			throw new IndexOutOfBoundsException("Index is negative! index=" + index);
		}
		// make sure the size field is valid
		updateCount();
		if (debug) {
			//logger.debug("index = {}, size = {}", index, size);
			//logger.debug("index  + deleted = {}, size = {}", index + removedItems.size(), size);
		}
		if ((index + removedItems.size()) < size) {
			if (itemIndexes.keySet().contains(index)) {
				if (debug) {
					//logger.debug("item " + index + " was found in itemIndexes");
				}
				return itemIndexes.get(index);
			}
			if (debug) {
				//logger.debug("item " + index + " was not found in itemIndexes");
			}
			updateOffsetAndCache(index);
			return itemIndexes.get(index);
		} else {
			// The index is in the added items
			int offset = index + removedItems.size() - size;
			// getItemIds(int, int)
			//logger.debug("index < size, looking in filtered added items.");
			//logger.debug("offset = {}", offset);
			return getFilteredAddedItems().get(offset).getId();
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<Object> getItemIds(int startIndex, int numberOfIds) {
		// Copied this function from the containerHelpers.
		return (List<Object>) ContainerHelpers.getItemIdsUsingGetIdByIndex(startIndex, numberOfIds, this);
		
		/*
		if (debug) 
			logger.debug("getItemIds({}, {})", startIndex, numberOfIds);
		int size = size();

        if (startIndex < 0) {
            throw new IndexOutOfBoundsException(
                    "Start index cannot be negative! startIndex=" + startIndex);
        }

        if (startIndex > size) {
            throw new IndexOutOfBoundsException(
                    "Start index exceeds container size! startIndex="
                            + startIndex + " containerLastItemIndex="
                            + (size - 1));
        }

        if (numberOfIds < 1) {
            if (numberOfIds == 0) {
                return Collections.emptyList();
            }

            throw new IllegalArgumentException(
                    "Cannot get negative amount of items! numberOfItems="
                            + numberOfIds);
        }

        // not included in the range
        int endIndex = startIndex + numberOfIds;

        if (endIndex > size) {
            endIndex = size;
        }

        ArrayList<Object> rangeOfIds = new ArrayList<Object>();
        for (int i = startIndex; i < endIndex; i++) {
            Object idByIndex = getIdByIndex(i);
            if (idByIndex == null) {
                throw new RuntimeException(
                        "Unable to get item id for index: "
                                + i
                                + " from container using Container.Indexed#getIdByIndex() "
                                + "even though container.size() > endIndex. "
                                + "Returned item id was null. "
                                + "Check your container implementation!");
            }
            rangeOfIds.add(idByIndex);
        }

        return Collections.unmodifiableList(rangeOfIds);
        */
		
	}

	/**********************************************/
	/** Methods from interface Container.Ordered **/
	/**********************************************/

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#nextItemId(java.lang.Object)
	 */

	@Override
	public Object nextItemId(Object itemId) {
		int index = indexOfId(itemId) + 1;
		try {
			return getIdByIndex(index);
		} catch (IndexOutOfBoundsException e) {
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#prevItemId(java.lang.Object)
	 */

	@Override
	public Object prevItemId(Object itemId) {
		int prevIndex = indexOfId(itemId) - 1;
		try {
			return getIdByIndex(prevIndex);
		} catch (IndexOutOfBoundsException e) {
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#firstItemId()
	 */

	@Override
	public Object firstItemId() {
		logger.debug("firstItemId");
		updateCount();
		if (size == 0) {
			logger.debug("size is 0");
			if (addedItems.isEmpty()) {
				logger.debug("addedItems is empty");
				return null;
			} else {
				int ix = -1;
				do {
					ix++;
					logger.debug("Searching ix in addedItems " + ix);
				} while (!itemPassesFilters(addedItems.get(ix)) && ix < addedItems.size());

				if (ix < addedItems.size()) {
					return addedItems.get(ix).getId();
				}
			}
		}

		if (!itemIndexes.containsKey(0)) {
			logger.debug("itemIndexes does not contain item 0 - updating cache");
			updateOffsetAndCache(0);
		}

		logger.debug("returning item 0 from itemIndexes");
		return itemIndexes.get(0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#lastItemId()
	 */

	@Override
	public Object lastItemId() {
		logger.debug("lastItemId");
		if (addedItems.isEmpty()) {
			logger.debug("addedItems is empty");
			int lastIx = size() - 1;
			logger.debug("lastIx = " + lastIx);
			if (!itemIndexes.containsKey(lastIx)) {
				logger.debug("cache does not contain " + lastIx + " - refreshing cache");
				updateOffsetAndCache(size - 1);
			}
			logger.debug("returning item " + lastIx + " from itemIndexes");
			return itemIndexes.get(lastIx);
		} else {
			logger.debug("searching addedItems");
			int ix = addedItems.size();
			do {
				ix--;
			} while (!itemPassesFilters(addedItems.get(ix)) && ix >= 0);
			if (ix >= 0) {
				logger.debug("found index in addedItems " + ix);
				return addedItems.get(ix).getId();
			} else {
				logger.debug("did not find index in addedItems");
				return null;
			}
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#isFirstId(java.lang.Object)
	 */

	@Override
	public boolean isFirstId(Object itemId) {
		return firstItemId().equals(itemId);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#isLastId(java.lang.Object)
	 */

	@Override
	public boolean isLastId(Object itemId) {
		return lastItemId().equals(itemId);
	}

	/***********************************************/
	/** Methods from interface Container.Sortable **/
	/***********************************************/

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Sortable#sort(java.lang.Object[],
	 * boolean[])
	 * 
	 * Only sorts by String value.
	 */

	@Override
	public void sort(Object[] propertyId, boolean[] ascending) {
		logger.debug("Old sort function called");
		sorters.clear();
		if (propertyId == null || propertyId.length == 0) {
			refresh();
			return;
		}
		/* Generate OrderBy -objects */
		boolean asc = true;
		for (int i = 0; i < propertyId.length; i++) {
			/* Check that the property id is valid */
			if (propertyId[i] instanceof String && propertyIds.contains(propertyId[i])) {
				try {
					asc = ascending[i];
				} catch (Exception e) {
					logger.warn("", e);
				}
				sorters.add(new OrderBy((String) propertyId[i], asc));
			}
		}
		refresh();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Sortable#getSortableContainerPropertyIds()
	 * 
	 * called by Table.paintVisibleColumns every time the table is refreshed.
	 */

	@Override
	public Collection<?> getSortableContainerPropertyIds() {
		return getContainerPropertyIds();
	}

	/**************************************/
	/** Methods specific to OldSQLContainer **/
	/**************************************/

	/**
	 * Refreshes the container - clears all caches and resets size and offset.
	 * Does NOT remove sorting or filtering rules!
	 */
	public void refresh() {
		refresh(true);
	}

	/**
	 * Refreshes the container. If <code>setSizeDirty</code> is
	 * <code>false</code>, assumes that the current size is up to date. This is
	 * used in {@link #updateCount()} to refresh the contents when we know the
	 * size was just updated.
	 * 
	 * @param setSizeDirty
	 */
	private void refresh(boolean setSizeDirty) {
		logger.debug("OldSQLContainer refresh");
		if (setSizeDirty) {
			sizeDirty = true;
		}
		currentOffset = 0;
		cachedItems.clear();
		itemIndexes.clear();
		fireContentsChange();
	}

	/**
	 * Returns modify state of the container.
	 * 
	 * @return true if contents of this container have been modified
	 */
	public boolean isModified() {
		return !removedItems.isEmpty() || !addedItems.isEmpty() || !modifiedItems.isEmpty();
	}

	/**
	 * Set auto commit mode enabled or disabled. Auto commit mode means that all
	 * changes made to items of this container will be immediately written to
	 * the underlying data source.
	 * 
	 * @param autoCommitEnabled
	 *            true to enable auto commit mode
	 */
	public void setAutoCommit(boolean autoCommitEnabled) {
		autoCommit = autoCommitEnabled;
	}

	/**
	 * Returns status of the auto commit mode.
	 * 
	 * @return true if auto commit mode is enabled
	 */
	public boolean isAutoCommit() {
		return autoCommit;
	}

	/**
	 * Returns the currently set page length.
	 * 
	 * @return current page length
	 */
	public int getPageLength() {
		return pageLength;
	}

	/**
	 * Sets the page length used in lazy fetching of items from the data source.
	 * Also resets the cache size to match the new page length.
	 * 
	 * As a side effect the container will be refreshed.
	 * 
	 * @param pageLength
	 *            new page length
	 */
	public void setPageLength(int pageLength) {
		setPageLengthInternal(pageLength);
		refresh();
	}

	/**
	 * Sets the page length internally, without refreshing the container.
	 * 
	 * @param pageLength
	 *            the new page length
	 */
	private void setPageLengthInternal(int pageLength) {
		this.pageLength = pageLength > 0 ? pageLength : DEFAULT_PAGE_LENGTH;
		cacheOverlap = getPageLength();
        cachedItems.setCacheLimit(CACHE_RATIO * getPageLength() + cacheOverlap);
	}

	/**
	 * 
	 * Allows deferred refresh for OrderBy setting.
	 * 
	 * @param refresh
	 * @author graumannc
	 */
	@Deprecated
	public void setOrderRefresh(boolean refresh) {
		setAutoRefresh(refresh);
	}

	/**
	 * Adds the given OrderBy to this container and refreshes the container
	 * contents with the new sorting rules.
	 * 
	 * Note that orderBy.getColumn() must return a column name that exists in
	 * this container.
	 * 
	 * @param orderBy
	 *            OrderBy to be added to the container sorting rules
	 */
	public void addOrderBy(OrderBy orderBy) {
		if (orderBy == null) {
			return;
		}
		if (!propertyIds.contains(orderBy.getColumn())) {
			throw new IllegalArgumentException("The column given for sorting does not exist in this container.");
		}
		sorters.add(orderBy);
		if (autoRefresh) {
			refresh();
		}
	}

	/**
	 * Commits all the changes, additions and removals made to the items of this
	 * container.
	 * 
	 * @throws UnsupportedOperationException
	 * @throws SQLException
	 */
	public void commit() throws UnsupportedOperationException, SQLException {
		try {
			logger.debug("Commiting changes through delegate...");
			logger.debug("delegate = {}", delegate);
			delegate.beginTransaction();
			
			logger.debug("removed Items = {}", removedItems.keySet());
			logger.debug("modified Items = {}", modifiedItems);
			logger.debug("added Items = {}", addedItems);
			
			/* Perform buffered deletions */
			for (RowItem item : removedItems.values()) {
				logger.debug("Perform buffered deletions..");
				if (!delegate.removeRow(item)) {
					throw new SQLException("Removal failed for row with ID: " + item.getId());
				}
			}
			/* Perform buffered modifications */
			for (RowItem item : modifiedItems) {
				logger.debug("Perform buffered modifications..");
				if (!removedItems.containsKey(item.getId())) {
					if (delegate.storeRow(item) > 0) {
						/*
						 * Also reset the modified state in the item in case it is
						 * reused e.g. in a form.
						 */
						item.commit();
					} else {
						delegate.rollback();
						refresh();
						throw new ConcurrentModificationException("Item with the ID '" + item.getId() + "' has been externally modified.");
					}
				} else {
					// Justin added this check, because an item can be modified and then deleted.
					// This was causing OldSQLContainer to delete the item and then save it as a modified item.
					// Basically making the deletion ineffective.
					logger.debug("id = {} was found in the removedItems, it will be skipped in the modified items");
				}
			}
			/* Perform buffered additions */
			for (RowItem item : addedItems) {
				logger.debug("Perform buffered additions..");
				delegate.storeRow(item);
			}
			delegate.commit();
			removedItems.clear();
			addedItems.clear();
			modifiedItems.clear();
			refresh();
			if (notificationsEnabled) {
				CacheFlushNotifier.notifyOfCacheFlush(this);
			}
		} catch (SQLException e) {
			delegate.rollback();
			throw e;
		} catch (OptimisticLockException e) {
			delegate.rollback();
			throw e;
		}
	}

	/**
	 * Rolls back all the changes, additions and removals made to the items of
	 * this container.
	 * 
	 * @throws UnsupportedOperationException
	 * @throws SQLException
	 */
	public void rollback() throws UnsupportedOperationException, SQLException {
		logger.debug("Rolling back changes...");
		removedItems.clear();
		addedItems.clear();
		modifiedItems.clear();
		refresh();
	}

	/**
	 * Notifies this container that a property in the given item has been
	 * modified. The change will be buffered or made instantaneously depending
	 * on auto commit mode.
	 * 
	 * @param changedItem
	 *            item that has a modified property
	 */
	void itemChangeNotification(RowItem changedItem) {
		if (autoCommit) {
			try {
				delegate.beginTransaction();
				if (delegate.storeRow(changedItem) == 0) {
					delegate.rollback();
					refresh();
					throw new ConcurrentModificationException("Item with the ID '" + changedItem.getId() + "' has been externally modified.");
				}
				delegate.commit();
				if (notificationsEnabled) {
					CacheFlushNotifier.notifyOfCacheFlush(this);
				}
				logger.debug("Row updated to DB...");
			} catch (SQLException e) {
				logger.warn("itemChangeNotification failed, rolling back...", e);
				try {
					delegate.rollback();
				} catch (SQLException ee) {
					/* Nothing can be done here */
					logger.error("Rollback failed", e);
				}
				throw new RuntimeException(e);
			}
		} else {
			if (!(changedItem.getId() instanceof TemporaryRowId) && !modifiedItems.contains(changedItem)) {
				modifiedItems.add(changedItem);
			}
		}
	}

	/**
	 * Determines a new offset for updating the row cache. The offset is
	 * calculated from the given index, and will be fixed to match the start of
	 * a page, based on the value of pageLength.
	 * 
	 * @param index
	 *            Index of the item that was requested, but not found in cache
	 */
	private void updateOffsetAndCache(int index) {
		if (debug) 
			logger.debug("updateOffsetAndCache({})", index);
		
		int oldOffset = currentOffset;
		
		currentOffset = (index / pageLength) * pageLength - cacheOverlap;

		if (currentOffset < 0) {
			currentOffset = 0;
		}

		if (oldOffset == currentOffset && !cachedItems.isEmpty()) {
			return;
		}

		getPage();
		
		/*
		logger.debug("updateOffsetAndCache : " + index);
		logger.debug("itemIndexes.size() = {}", itemIndexes.size());
		if (itemIndexes.keySet().contains(index)) {
			logger.debug("itemIndex found {}, checking cachedItems", index);
			// modified to check to make sure the cachedItem is actually in the cachedItems,
			// because itemIndexes can contain the index, but the cachedItems may no longer have it.
			if (cachedItems.keySet().contains(new RowId(itemIndexes.get(index)))) {
				if (logger.isDebugEnabled()) {
					logger.debug("itemIndexes contains {}", index);
				}
				return;
			}
		}
		logger.debug("currentOffset = {}, index = {}", new Object[]{currentOffset, index});
		currentOffset = (index / (pageLength * CACHE_RATIO)) * (pageLength * CACHE_RATIO);
		
		if (currentOffset < 0) {
			currentOffset = 0;
		}
		if (logger.isDebugEnabled()) {
			logger.debug("itemIndexes does not contain {} calculated currentOffset = {}", index, currentOffset);
		}
		getPage();
		*/
	}

	/**
	 * Fetches new count of rows from the data source, if needed.
	 */
	private void updateCount() {
		if (debug) 
			logger.debug("updateCount()");
		if (!sizeDirty && new Date().getTime() < sizeUpdated.getTime() + sizeValidMilliSeconds) {
			return;
		}
		try {
			try {
				logger.debug("setting delgate filters {}", filters != null ? filters.size() : 0);
				delegate.setFilters(filters);
			} catch (UnsupportedOperationException e) {
				logger.debug("The query delegate doesn't support filtering", e);
			}
			try {
				delegate.setOrderBy(sorters);
			} catch (UnsupportedOperationException e) {
				logger.debug("The query delegate doesn't support sorting", e);
			}
			int newSize = delegate.getCount();
			sizeUpdated = new Date();
			sizeDirty = false;
			if (newSize != size) {
				size = newSize;
				// Size is up to date so don't set it back to dirty in refresh()
				refresh(false);
			}
			if (debug) 
				logger.debug("Updated row count. New count is: {}", size);
		} catch (SQLException e) {
			throw new RuntimeException("Failed to update item set size.", e);
		}
	}

	public interface ObjectMapper {

		public boolean handlesColumn(String columnName);

		public Class<?> assignType(String columnName);

		public Class<?> assignType(Class<?> columnClass, int precision, int scale);

		public Object createObject(Object object, Class<?> columnClass);

		public Object createObject(String columnName, ResultSet rs) throws SQLException;

	}

	protected ObjectMapper objectMapper = null;

	/**
	 * Fetches property id's (column names and their types) from the data
	 * source.
	 * 
	 * @throws SQLException
	 */
	private void getPropertyIds() throws SQLException {
		propertyIds.clear();
		propertyTypes.clear();
		delegate.setFilters(null);
		delegate.setOrderBy(null);
		ResultSet rs = null;
		ResultSetMetaData rsmd = null;
		try {
			delegate.beginTransaction();
			rs = delegate.getResults(0, 1);
			rsmd = rs.getMetaData();
			boolean resultExists = rs.next();
			Class<?> type = null;
			for (int i = 1; i <= rsmd.getColumnCount(); i++) {
				if (!isColumnIdentifierValid(rsmd.getColumnLabel(i))) {
					continue;
				}
				String colName = rsmd.getColumnLabel(i);
				/*
				 * Make sure not to add the same colName twice. This can easily
				 * happen if the SQL query joins many tables with an ID column.
				 */
				if (!propertyIds.contains(colName)) {
					propertyIds.add(colName);
				}
				if (debug) 
					logger.debug("Determining Type for Column " + colName);
				/* Try to determine the column's JDBC class by all means. */
				if (overrideTypes.containsKey(colName)) {
					// Manual Override of type.
					type = overrideTypes.get(colName);
				} else if (objectMapper != null) {

					if (objectMapper.handlesColumn(colName)) {
						// ObjectMapper Explicit Override of type based on
						// column Name;
						type = objectMapper.assignType(colName);
					} else if (resultExists && rs.getObject(i) != null) {
						// ObjectMapper standardizes based on Objects and
						// resultset metadata.
						type = objectMapper.assignType(rs.getObject(i).getClass(), rsmd.getPrecision(i), rsmd.getScale(i));
					} else {
						if (debug) 
							logger.debug("Metadata class name = " + rsmd.getColumnClassName(i));
						try {
							// ObjectMapper standardizes based on Column Class
							// returned by JDBC driver and resultset metadata
							
							//TODO DOES NOT HANDLE byte[] as used by UUID
							
							type = objectMapper.assignType(Class.forName(rsmd.getColumnClassName(i)), rsmd.getPrecision(i), rsmd.getScale(i));
						} catch (Exception e) {
							logger.warn("Class not found");
							/*
							 * On failure revert to Object and hope for the
							 * best.
							 */
							type = Object.class;
						}
					}

				} else if (resultExists && rs.getObject(i) != null) {
					logger.debug("Default type assignment");
					type = rs.getObject(i).getClass();
				} else {
					try {
						type = Class.forName(rsmd.getColumnClassName(i));
					} catch (Exception e) {
						logger.warn("Class not found", e);
						/* On failure revert to Object and hope for the best. */
						type = Object.class;
					}
				}
				if (debug) 
					logger.debug("type = {}", type);

				/*
				 * Determine read only and nullability status of the column. A
				 * column is read only if it is reported as either read only or
				 * auto increment by the database, and also it is set as the
				 * version column in a TableQuery delegate.
				 */
				boolean readOnly = rsmd.isAutoIncrement(i) || rsmd.isReadOnly(i);

				boolean persistable = !rsmd.isReadOnly(i);

				if (delegate instanceof TableQuery) {
					if (rsmd.getColumnLabel(i).equals(((TableQuery) delegate).getVersionColumn())) {
						readOnly = true;
					}
				}

				propertyReadOnly.put(colName, readOnly);
				propertyPersistable.put(colName, persistable);
				propertyNullable.put(colName, rsmd.isNullable(i) == ResultSetMetaData.columnNullable);
				propertyPrimaryKey.put(colName, delegate.getPrimaryKeyColumns().contains(rsmd.getColumnLabel(i)));
				propertyTypes.put(colName, type);
			}
			rs.getStatement().close();
			rs.close();
			delegate.commit();
			logger.debug("Property IDs fetched.");
		} catch (SQLException e) {
			logger.warn("Failed to fetch property ids, rolling back", e);
			try {
				delegate.rollback();
			} catch (SQLException e1) {
				logger.error("Failed to roll back", e1);
			}
			try {
				if (rs != null) {
					if (rs.getStatement() != null) {
						rs.getStatement().close();
					}
					rs.close();
				}
			} catch (SQLException e1) {
				logger.warn("Failed to close session", e1);
			}
			throw e;
		}
	}

	/**
	 * Fetches a page from the data source based on the values of pageLenght and
	 * currentOffset. Also updates the set of primary keys, used in
	 * identification of RowItems.
	 */
	private void getPage() {
		if (debug) 
			logger.debug("getPage()");
		updateCount();
		logger.debug("Size = {}", size);
		ResultSet rs = null;
		ResultSetMetaData rsmd = null;
		//cachedItems.clear(); // Why are we clearing?
		//itemIndexes.clear(); // Why are we clearing?
		try {
			try {
				delegate.setOrderBy(sorters);
			} catch (UnsupportedOperationException e) {
				/* The query delegate doesn't support sorting. */
				/* No need to do anything. */
				logger.debug("The query delegate doesn't support sorting", e);
			}
			delegate.beginTransaction();
			int fetchedRows = pageLength * CACHE_RATIO + cacheOverlap;
			rs = delegate.getResults(currentOffset, fetchedRows);
			rsmd = rs.getMetaData();
			List<String> pKeys = delegate.getPrimaryKeyColumns();
			// }
			/* Create new items and column properties */
			ColumnProperty cp = null;
			int rowCount = currentOffset;
			if (!delegate.implementationRespectsPagingLimits()) {
				rowCount = currentOffset = 0;
				setPageLengthInternal(size);
			}
			while (rs.next()) {
				List<ColumnProperty> itemProperties = new ArrayList<ColumnProperty>();
				/* Generate row itemId based on primary key(s) */
				Object[] itemId = new Object[pKeys.size()];
				for (int i = 0; i < pKeys.size(); i++) {
					itemId[i] = rs.getObject(pKeys.get(i));
				}
				RowId id = null;
				if (pKeys.isEmpty()) {
					id = new ReadOnlyRowId(rs.getRow());
				} else {
					id = new RowId(itemId);
				}
				List<String> propertiesToAdd = new ArrayList<String>(propertyIds);
				if (!removedItems.containsKey(id)) {
					for (int i = 1; i <= rsmd.getColumnCount(); i++) {
						if (!isColumnIdentifierValid(rsmd.getColumnLabel(i))) {
							continue;
						}
						String colName = rsmd.getColumnLabel(i);

						Object value = rs.getObject(i);
						Class<?> type;
						if (value != null) {

							if (objectMapper == null) {
								type = value.getClass();
							} else {

								if (overrideTypes.containsKey(colName)) {
									
									if (logger.isDebugEnabled()) {
										// logger.debug("Column Type is overridden for {}",colName);
									}
									type = overrideTypes.get(colName);
									value = objectMapper.createObject(value, type);

								} else if(objectMapper.handlesColumn(colName)) {
									
									value = objectMapper.createObject(colName, rs);
									type = value.getClass();
									
								} else {

									if (logger.isDebugEnabled()) {
										// logger.debug("Column Type is not overridden for {}",colName);
									}

									value = objectMapper.createObject(value, objectMapper.assignType(value.getClass(), rsmd.getPrecision(i), rsmd.getScale(i)));
									type = value.getClass();
								}
								
							}

						} else {
							type = Object.class;
							for (String propName : propertyTypes.keySet()) {
								if (propName.equals(rsmd.getColumnLabel(i))) {
									type = propertyTypes.get(propName);
									break;
								}
							}
						}
						/*
						 * In case there are more than one column with the same
						 * name, add only the first one. This can easily happen
						 * if you join many tables where each table has an ID
						 * column.
						 */
						if (propertiesToAdd.contains(colName)) {
							//logger.debug("value class = {}, type = {}", value != null ? value.getClass() : null, type);
							cp = new ColumnProperty(colName, propertyReadOnly.get(colName), propertyPersistable.get(colName), propertyNullable.get(colName),
									propertyPrimaryKey.get(colName), value, type);
							itemProperties.add(cp);
							propertiesToAdd.remove(colName);
						}
					}
					/* Cache item */
					if (debug) {
						logger.debug("Caching index in itemIndexes {} {}", rowCount, id);
					}
					itemIndexes.put(rowCount, id);

					// if an item with the id is contained in the modified
					// cache, then use this record and add it to the cached
					// items. Otherwise create a new item
					int modifiedIndex = indexInModifiedCache(id);
					if (modifiedIndex != -1) {
						cachedItems.put(id, modifiedItems.get(modifiedIndex));
					} else {
						cachedItems.put(id, new RowItem(this, id, itemProperties));
					}

					rowCount++;
				}
			}
			rs.getStatement().close();
			rs.close();
			delegate.commit();
			if (logger.isDebugEnabled()) {
				logger.debug("Fetched {} rows starting from {}", new Object[] { fetchedRows, currentOffset });
			}
		} catch (SQLException e) {
			logger.error("Failed to fetch rows, rolling back", e);
			try {
				delegate.rollback();
			} catch (SQLException e1) {
				logger.error("Failed to roll back", e1);
			}
			try {
				if (rs != null) {
					if (rs.getStatement() != null) {
						rs.getStatement().close();
						rs.close();
					}
				}
			} catch (SQLException e1) {
				logger.error("Failed to close session", e1);
			}
			throw new RuntimeException("Failed to fetch page.", e);
		}
	}

	/**
	 * Returns the index of the item with the given itemId for the modified
	 * cache.
	 * 
	 * @param itemId
	 * @return the index of the item with the itemId in the modified cache. Or
	 *         -1 if not found.
	 */
	private int indexInModifiedCache(Object itemId) {
		for (int ix = 0; ix < modifiedItems.size(); ix++) {
			RowItem item = modifiedItems.get(ix);
			if (item.getId().equals(itemId)) {
				return ix;
			}
		}
		return -1;
	}

	private int sizeOfAddedItems() {
		return getFilteredAddedItems().size();
	}

	private List<RowItem> getFilteredAddedItems() {
		ArrayList<RowItem> filtered = new ArrayList<RowItem>(addedItems);
		if (filters != null && !filters.isEmpty()) {
			for (RowItem item : addedItems) {
				if (!itemPassesFilters(item)) {
					filtered.remove(item);
				}
			}
		}
		return filtered;
	}

	public boolean itemPassesFilters(RowItem item) {
		for (Filter filter : filters) {
			if (!filter.passesFilter(item.getId(), item)) {
				logger.debug("filter not passed = {}", filter);
				return false;
			}
		}
		return true;
	}

	/**
	 * Checks is the given column identifier valid to be used with OldSQLContainer.
	 * Currently the only non-valid identifier is "rownum" when MSSQL or Oracle
	 * is used. This is due to the way the SELECT queries are constructed in
	 * order to implement paging in these databases.
	 * 
	 * @param identifier
	 *            Column identifier
	 * @return true if the identifier is valid
	 */
	private boolean isColumnIdentifierValid(String identifier) {
		if (identifier.equalsIgnoreCase("rownum") && delegate instanceof TableQuery) {
			TableQuery tq = (TableQuery) delegate;
			if (tq.getSqlGenerator() instanceof MSSQLGenerator || tq.getSqlGenerator() instanceof OracleGenerator) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns the QueryDelegate set for this OldSQLContainer.
	 * 
	 * @return current querydelegate
	 */
	public QueryDelegate getQueryDelegate() {
		return delegate;
	}
	
	public void setQueryDelegate(QueryDelegate delegate) throws SQLException {
		if (delegate == null) {
			throw new IllegalArgumentException("QueryDelegate must not be null.");
		}
		this.delegate = delegate;
		getPropertyIds();
		//cachedItems.setCacheLimit(CACHE_RATIO * getPageLength());
	}

	/************************************/
	/** UNSUPPORTED CONTAINER FEATURES **/
	/************************************/

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#addContainerProperty(java.lang.Object,
	 * java.lang.Class, java.lang.Object)
	 */

	@Override
	public boolean addContainerProperty(Object propertyId, Class<?> type, Object defaultValue) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#removeContainerProperty(java.lang.Object)
	 */

	@Override
	public boolean removeContainerProperty(Object propertyId) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container#addItem(java.lang.Object)
	 */

	@Override
	public Item addItem(Object itemId) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#addItemAfter(java.lang.Object,
	 * java.lang.Object)
	 */

	@Override
	public Item addItemAfter(Object previousItemId, Object newItemId) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Indexed#addItemAt(int, java.lang.Object)
	 */

	@Override
	public Item addItemAt(int index, Object newItemId) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Indexed#addItemAt(int)
	 */

	@Override
	public Object addItemAt(int index) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.vaadin.data.Container.Ordered#addItemAfter(java.lang.Object)
	 */

	@Override
	public Object addItemAfter(Object previousItemId) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

	/******************************************/
	/** ITEMSETCHANGENOTIFIER IMPLEMENTATION **/
	/******************************************/

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * com.vaadin.data.Container.ItemSetChangeNotifier#addListener(com.vaadin
	 * .data.Container.ItemSetChangeListener)
	 */

	@Override
	public void addItemSetChangeListener(Container.ItemSetChangeListener listener) {
		if (itemSetChangeListeners == null) {
			itemSetChangeListeners = new LinkedList<Container.ItemSetChangeListener>();
		}
		itemSetChangeListeners.add(listener);
	}

	/**
	 * @deprecated As of 7.0, replaced by
	 *             {@link #addItemSetChangeListener(com.vaadin.data.Container.ItemSetChangeListener)}
	 **/
	@Override
	@Deprecated
	public void addListener(Container.ItemSetChangeListener listener) {
		addItemSetChangeListener(listener);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * com.vaadin.data.Container.ItemSetChangeNotifier#removeListener(com.vaadin
	 * .data.Container.ItemSetChangeListener)
	 */

	@Override
	public void removeItemSetChangeListener(Container.ItemSetChangeListener listener) {
		if (itemSetChangeListeners != null) {
			itemSetChangeListeners.remove(listener);
		}
	}

	/**
	 * @deprecated As of 7.0, replaced by
	 *             {@link #removeItemSetChangeListener(com.vaadin.data.Container.ItemSetChangeListener)}
	 **/
	@Override
	@Deprecated
	public void removeListener(Container.ItemSetChangeListener listener) {
		removeItemSetChangeListener(listener);
	}

	protected void fireContentsChange() {
		if (itemSetChangeListeners != null) {
			final Object[] l = itemSetChangeListeners.toArray();
			final Container.ItemSetChangeEvent event = new OldSQLContainer.ItemSetChangeEvent(this);
			for (int i = 0; i < l.length; i++) {
				((Container.ItemSetChangeListener) l[i]).containerItemSetChange(event);
			}
		}
	}

	/**
	 * Simple ItemSetChangeEvent implementation.
	 */
	public static class ItemSetChangeEvent extends EventObject implements Container.ItemSetChangeEvent {

		private ItemSetChangeEvent(OldSQLContainer source) {
			super(source);
		}

		@Override
		public Container getContainer() {
			return (Container) getSource();
		}
	}

	/**************************************************/
	/** ROWIDCHANGELISTENER PASSING TO QUERYDELEGATE **/
	/**************************************************/

	/**
	 * Adds a RowIdChangeListener to the QueryDelegate
	 * 
	 * @param listener
	 */
	public void addRowIdChangeListener(RowIdChangeListener listener) {
		if (delegate instanceof QueryDelegate.RowIdChangeNotifier) {
			((QueryDelegate.RowIdChangeNotifier) delegate).addRowIdChangeListener(listener);
		}
	}

	/**
	 * @deprecated As of 7.0, replaced by
	 *             {@link #addRowIdChangeListener(RowIdChangeListener)}
	 **/
	@Deprecated
	public void addListener(RowIdChangeListener listener) {
		addRowIdChangeListener(listener);
	}

	/**
	 * Removes a RowIdChangeListener from the QueryDelegate
	 * 
	 * @param listener
	 */
	public void removeRowIdChangeListener(RowIdChangeListener listener) {
		if (delegate instanceof QueryDelegate.RowIdChangeNotifier) {
			((QueryDelegate.RowIdChangeNotifier) delegate).removeRowIdChangeListener(listener);
		}
	}

	/**
	 * @deprecated As of 7.0, replaced by
	 *             {@link #removeRowIdChangeListener(RowIdChangeListener)}
	 **/
	@Deprecated
	public void removeListener(RowIdChangeListener listener) {
		removeRowIdChangeListener(listener);
	}

	/**
	 * Calling this will enable this OldSQLContainer to send and receive cache
	 * flush notifications for its lifetime.
	 */
	public void enableCacheFlushNotifications() {
		if (!notificationsEnabled) {
			notificationsEnabled = true;
			CacheFlushNotifier.addInstance(this);
		}
	}

	/******************************************/
	/** Referencing mechanism implementation **/
	/******************************************/

	/**
	 * Adds a new reference to the given OldSQLContainer. In addition to the
	 * container you must provide the column (property) names used for the
	 * reference in both this and the referenced OldSQLContainer.
	 * 
	 * Note that multiple references pointing to the same OldSQLContainer are not
	 * supported.
	 * 
	 * @param refdCont
	 *            Target OldSQLContainer of the new reference
	 * @param refingCol
	 *            Column (property) name in this container storing the (foreign
	 *            key) reference
	 * @param refdCol
	 *            Column (property) name in the referenced container storing the
	 *            referenced key
	 */
	public void addReference(OldSQLContainer refdCont, String refingCol, String refdCol) {
		if (refdCont == null) {
			throw new IllegalArgumentException("Referenced OldSQLContainer can not be null.");
		}
		if (!getContainerPropertyIds().contains(refingCol)) {
			throw new IllegalArgumentException("Given referencing column name is invalid." + " Please ensure that this container"
					+ " contains a property ID named: " + refingCol);
		}
		if (!refdCont.getContainerPropertyIds().contains(refdCol)) {
			throw new IllegalArgumentException("Given referenced column name is invalid." + " Please ensure that the referenced container"
					+ " contains a property ID named: " + refdCol);
		}
		if (references.keySet().contains(refdCont)) {
			throw new IllegalArgumentException("An OldSQLContainer instance can only be referenced once.");
		}
		references.put(refdCont, new Reference(refdCont, refingCol, refdCol));
	}

	/**
	 * Removes the reference pointing to the given OldSQLContainer.
	 * 
	 * @param refdCont
	 *            Target OldSQLContainer of the reference
	 * @return true if successful, false if the reference did not exist
	 */
	public boolean removeReference(OldSQLContainer refdCont) {
		if (refdCont == null) {
			throw new IllegalArgumentException("Referenced OldSQLContainer can not be null.");
		}
		return references.remove(refdCont) == null ? false : true;
	}

	/**
	 * Sets the referenced item. The referencing column of the item in this
	 * container is updated accordingly.
	 * 
	 * @param itemId
	 *            Item Id of the reference source (from this container)
	 * @param refdItemId
	 *            Item Id of the reference target (from referenced container)
	 * @param refdCont
	 *            Target OldSQLContainer of the reference
	 * @return true if the referenced item was successfully set, false on
	 *         failure
	 */
	@SuppressWarnings("unchecked")
	public boolean setReferencedItem(Object itemId, Object refdItemId, OldSQLContainer refdCont) {
		if (refdCont == null) {
			throw new IllegalArgumentException("Referenced OldSQLContainer can not be null.");
		}
		Reference r = references.get(refdCont);
		if (r == null) {
			throw new IllegalArgumentException("Reference to the given OldSQLContainer not defined.");
		}
		try {
			getContainerProperty(itemId, r.getReferencingColumn()).setValue(refdCont.getContainerProperty(refdItemId, r.getReferencedColumn()));
			return true;
		} catch (Exception e) {
			logger.warn("Setting referenced item failed.", e);
			return false;
		}
	}

	/**
	 * Fetches the Item Id of the referenced item from the target OldSQLContainer.
	 * 
	 * @param itemId
	 *            Item Id of the reference source (from this container)
	 * @param refdCont
	 *            Target OldSQLContainer of the reference
	 * @return Item Id of the referenced item, or null if not found
	 */
	public Object getReferencedItemId(Object itemId, OldSQLContainer refdCont) {
		if (refdCont == null) {
			throw new IllegalArgumentException("Referenced OldSQLContainer can not be null.");
		}
		Reference r = references.get(refdCont);
		if (r == null) {
			throw new IllegalArgumentException("Reference to the given OldSQLContainer not defined.");
		}
		Object refKey = getContainerProperty(itemId, r.getReferencingColumn()).getValue();

		refdCont.removeAllContainerFilters();
		refdCont.addContainerFilter(new Equal(r.getReferencedColumn(), refKey));
		Object toReturn = refdCont.firstItemId();
		refdCont.removeAllContainerFilters();
		return toReturn;
	}

	/**
	 * Fetches the referenced item from the target OldSQLContainer.
	 * 
	 * @param itemId
	 *            Item Id of the reference source (from this container)
	 * @param refdCont
	 *            Target OldSQLContainer of the reference
	 * @return The referenced item, or null if not found
	 */
	public Item getReferencedItem(Object itemId, OldSQLContainer refdCont) {
		return refdCont.getItem(getReferencedItemId(itemId, refdCont));
	}

	private void writeObject(java.io.ObjectOutputStream out) throws IOException {
		out.defaultWriteObject();
	}

	private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
		in.defaultReadObject();
		if (notificationsEnabled) {
			/*
			 * Register instance with CacheFlushNotifier after de-serialization
			 * if notifications are enabled
			 */
			CacheFlushNotifier.addInstance(this);
		}
	}

	/**
	 * Justin added to find an item by a specific property and value.
	 * 
	 * @param propertyId
	 * @param value
	 * @return Item found or null
	 * @author reynoldsjj
	 */
	// TODO -- change this to be able to find an item by multiple properties
	public Item getItemByProperty(Object propertyId, Object value) {
		if (propertyId == null || !propertyIds.contains(propertyId)) {
			return null;
		}
		for (int i = 0; i < size(); i++) {
			// System.out.println(getContainerProperty(getIdByIndex(i),
			// propertyId) + " = " + value);
			if (String.valueOf(getContainerProperty(getIdByIndex(i), propertyId).getValue()).equals(String.valueOf(value))) {
				logger.debug("propertyId = {}, compared {} = {}", new Object[] { propertyId, getContainerProperty(getIdByIndex(i), propertyId).getValue(), value });
				return getItem(getIdByIndex(i));
			}
		}
		return null;
	}
	
	/**
	 * Quick way to get an item without having to worry about searching through the entire
	 * OldSQLContainer. {@link OldSQLContainer#getItem(Object)} will search through the entire container
	 * and load everything into the cache until it finds the itemId given.
	 * @param itemId
	 * @return Item found or null if not found.
	 * @author reynoldsjj
	 */
	public Item getItemById(RowId itemId) {
		
		// First check if the id is in the added items
		for (int ix = 0; ix < addedItems.size(); ix++) {
			RowItem item = addedItems.get(ix);
			if (item.getId().equals(itemId)) {
				if (itemPassesFilters(item)) {
					return item;
				} else {
					return null;
				}
			}
		}
		
		ResultSet rs = null;
		ResultSetMetaData rsmd = null;
		try {
			
			rs = ((OracleQuery) delegate).getItemResult(itemId);
			rsmd = rs.getMetaData();
			
			/* Create new items and column properties */
			ColumnProperty cp = null;
			while (rs.next()) {
				List<ColumnProperty> itemProperties = new ArrayList<ColumnProperty>();

				List<String> propertiesToAdd = new ArrayList<String>(propertyIds);
				if (!removedItems.containsKey(itemId)) {
					for (int i = 1; i <= rsmd.getColumnCount(); i++) {
						if (!isColumnIdentifierValid(rsmd.getColumnLabel(i))) {
							continue;
						}
						String colName = rsmd.getColumnLabel(i);

						Object value = rs.getObject(i);
						Class<?> type;
						if (value != null) {

							if (objectMapper == null) {
								type = value.getClass();
							} else {

								if (overrideTypes.containsKey(colName)) {
									
									if (logger.isDebugEnabled()) {
										// logger.debug("Column Type is overridden for {}",colName);
									}
									type = overrideTypes.get(colName);
									value = objectMapper.createObject(value, type);

								} else if(objectMapper.handlesColumn(colName)) {
									
									value = objectMapper.createObject(colName, rs);
									type = value.getClass();
									
								} else {

									if (logger.isDebugEnabled()) {
										// logger.debug("Column Type is not overridden for {}",colName);
									}

									value = objectMapper.createObject(value, objectMapper.assignType(value.getClass(), rsmd.getPrecision(i), rsmd.getScale(i)));
									type = value.getClass();
								}
								
							}

						} else {
							type = Object.class;
							for (String propName : propertyTypes.keySet()) {
								if (propName.equals(rsmd.getColumnLabel(i))) {
									type = propertyTypes.get(propName);
									break;
								}
							}
						}
						/*
						 * In case there are more than one column with the same
						 * name, add only the first one. This can easily happen
						 * if you join many tables where each table has an ID
						 * column.
						 */
						if (propertiesToAdd.contains(colName)) {
							//logger.debug("value class = {}, type = {}", value != null ? value.getClass() : null, type);
							cp = new ColumnProperty(colName, propertyReadOnly.get(colName), propertyPersistable.get(colName), propertyNullable.get(colName),
									propertyPrimaryKey.get(colName), value, type);
							itemProperties.add(cp);
							propertiesToAdd.remove(colName);
						}
					}
					// if an item with the id is contained in the modified
					// cache, then use this record and add it to the cached
					// items. Otherwise create a new item
					int modifiedIndex = indexInModifiedCache(itemId);
					if (modifiedIndex != -1) {
						return modifiedItems.get(modifiedIndex);
					} else {
						return new RowItem(this, itemId, itemProperties);
					}

				}
			}
			rs.getStatement().close();
			rs.close();
		} catch (SQLException e) {
			logger.error("Failed to fetch rows, rolling back", e);
			try {
				if (rs != null) {
					if (rs.getStatement() != null) {
						rs.getStatement().close();
						rs.close();
					}
				}
			} catch (SQLException e1) {
				logger.error("Failed to close session", e1);
			}
			throw new RuntimeException("Failed to fetch page.", e);
		}
		
		return null;
		
	}

	/**
	 * @return the autoRefresh
	 */
	public boolean isAutoRefresh() {
		return autoRefresh;
	}

	/**
	 * @param autoRefresh the autoRefresh to set
	 */
	public void setAutoRefresh(boolean autoRefresh) {
		this.autoRefresh = autoRefresh;
		logger.debug("setAutoRefresh({})", autoRefresh);
		if (autoRefresh) {
			refresh();
		}
	}
	
	public void setIsComboBox(boolean isComboBox) {
		this.isComboBox = isComboBox;
	}

}
